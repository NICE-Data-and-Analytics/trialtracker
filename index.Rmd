---
title: "Trial Tracker Dashboard"
output:
  flexdashboard::flex_dashboard:
    orientation: rows
    theme:
      version: 5
      bootswatch: flatly
      "enable-dark-mode": false
runtime: shiny
---

```{r setup, context="server", echo=FALSE, include=FALSE}

# DB path
db_path <- base::file.path("inst", "extdata", "RSQLite_data", "TrialTracker-db.sqlite")

# Pool connection (more robust than 'plain' DBI)
pool_con <- pool::dbPool(RSQLite::SQLite(), dbname = db_path)
shiny::onStop(function() pool::poolClose(pool_con))

# PRAGMAs for db performance (might be overkill)
DBI::dbExecute(pool_con, "PRAGMA journal_mode=WAL;")
DBI::dbExecute(pool_con, "PRAGMA synchronous=NORMAL;")
DBI::dbExecute(pool_con, "PRAGMA temp_store=MEMORY;")
DBI::dbExecute(pool_con, "PRAGMA mmap_size=134217728;")

# Refresh reactive (replaces last_refreshed + observe/invalidateLater) 
mtime_reader <- shiny::reactiveFileReader(
  intervalMillis = 3000L,
  session        = shiny::getDefaultReactiveDomain(),
  filePath       = db_path,
  readFunc       = function(path) base::file.info(path)$mtime
)

# Function to update UI after add/remove/archive
invalidate_cache <- function() { base::invisible(mtime_reader()) }

# Regex patterns
NCT_pattern    <- "^NCT[0-9]{8}$"
EU_pattern     <- "^[0-9]{4}-[0-9]{6}-[0-9]{2}$"
ISRCTN_pattern <- "^ISRCTN[0-9]{8}$"
NIHR_pattern   <- "(NIHR[0-9]{0,6})|(RP-PG-[0-9]{4}-[0-9]{4,5})|([0-9]{2,3}[/-][0-9]{2,4}[/-][0-9]{2,4})|(^ICA-.*-[0-9]{3})"

# Cached PM tables (small enough not to need other solution)
raw_tables <- shiny::reactive({
  mtime_reader()
  tbls <- DBI::dbListTables(pool_con)
  base::list(
    Trial_Ids = if ("Trial_Ids" %in% tbls) DBI::dbReadTable(pool_con, "Trial_Ids") else base::data.frame(),
    NCT_PM    = if ("NCT_PM"    %in% tbls) DBI::dbReadTable(pool_con, "NCT_PM")    else base::data.frame(),
    ISRCTN_PM = if ("ISRCTN_PM" %in% tbls) DBI::dbReadTable(pool_con, "ISRCTN_PM") else base::data.frame(),
    NIHR_PM   = if ("NIHR_PM"   %in% tbls) DBI::dbReadTable(pool_con, "NIHR_PM")   else base::data.frame(),
    EU_PM     = if ("EU_PM"     %in% tbls) DBI::dbReadTable(pool_con, "EU_PM")     else base::data.frame()
  )
})

# ID vectors (reactive)
nct_ids <- shiny::reactive({
  ids <- raw_tables()[["Trial_Ids"]][["NCT_Ids"]]
  if (is.null(ids)) character()
  unique(ids[!is.na(ids) & nzchar(ids)])
})
isr_ids <- shiny::reactive({
  ids <- raw_tables()[["Trial_Ids"]][["ISRCTN_Ids"]]
  if (is.null(ids)) character()
  unique(ids[!is.na(ids) & nzchar(ids)])
})
nihr_ids <- shiny::reactive({
  ids <- raw_tables()[["Trial_Ids"]][["NIHR_Ids"]]
  if (is.null(ids)) character()
  # Normalize by stripping non-digits when matching downstream
  ids <- gsub("[^0-9]", "", ids)
  ids[nzchar(ids)]
  unique(ids[nzchar(ids)])
})
eu_ids <- shiny::reactive({
  ids <- raw_tables()[["Trial_Ids"]][["EU_Ids"]]
  if (is.null(ids)) character()
  unique(ids[!is.na(ids) & nzchar(ids)])
})

# Helpers
clean_utf8 <- function(x) enc2utf8(base::as.character(x))  # minimal & vectorized
fast_trunc <- function(x, n = 120L) {                      # UI-only truncation, cheap
  x <- base::as.character(x); i <- base::nchar(x) > n
  x[i] <- base::paste0(base::substr(x[i], 1L, n), "…"); x
}
latest_sql <- function(table, id_col) {
  table_q <- .qidt(table); id_q <- .qidt(id_col)
  sprintf('
    SELECT *
    FROM (
      SELECT t.*,
             ROW_NUMBER() OVER (PARTITION BY %s ORDER BY "Query_Date" DESC) AS rn
      FROM %s t
    )
    WHERE rn = 1
  ', id_q, table_q)
}
last_two_cte_sql <- function(table, id_col) {              # why: compute last two rows once; join for diffs
  glue::glue("
    last2 AS (
      SELECT
        *,
        ROW_NUMBER() OVER (PARTITION BY {id_col} ORDER BY Query_Date DESC) AS rn
      FROM {table}
    ),
    n AS (SELECT * FROM last2 WHERE rn = 1),
    o AS (SELECT * FROM last2 WHERE rn = 2)
  ")
}
.with_temp_ids <- function(pool, tmp_name, id_col, ids, code_fn) {
  id_col_q <- .qidt(id_col)
  tmp_q    <- .qidt(tmp_name)
  DBI::dbExecute(pool, sprintf("DROP TABLE IF EXISTS %s;", tmp_q))
  DBI::dbExecute(pool, sprintf("CREATE TEMP TABLE %s (%s TEXT PRIMARY KEY);", tmp_q, id_col_q))
  if (length(ids)) {
    df <- stats::setNames(base::data.frame(ids, check.names = FALSE), gsub('"','', id_col_q, fixed = TRUE))
    DBI::dbWriteTable(pool, tmp_name, df, append = TRUE)
  }
  on.exit(DBI::dbExecute(pool, sprintf("DROP TABLE IF EXISTS %s;", tmp_q)), add = TRUE)
  force(code_fn(length(ids) > 0L))
}
sel_front <- function(.df, front) {
  dplyr::select(.df, dplyr::all_of(front), dplyr::everything())
}

# SQL Quoting helpers
.qi <- function(x) as.character(DBI::dbQuoteIdentifier(pool_con, x))
.qq <- function(alias, col) sprintf('%s."%s"', alias, gsub("`", "", col, fixed = TRUE))
.qcols <- function(alias, cols) vapply(cols, function(c) .qq(alias, c), character(1))
.qidt <- function(x) sprintf('"%s"', gsub("`", "", x, fixed = TRUE))  # "col" or "table"

# DT options (server for big tables; client for smaller PubMed tables)
dt_opts_server <- base::list(pageLength = 50L, lengthMenu = c(25L, 50L, 100L), deferRender = TRUE, searchDelay = 300L, dom = "tip")
dt_opts_client <- base::list(pageLength = 25L, dom = "tip")

# Table wrappers (so chunks that still call *_data() have data)
nct_tbl  <- shiny::reactive({ if ("NCT"    %in% DBI::dbListTables(pool_con)) DBI::dbGetQuery(pool_con, 'SELECT * FROM "NCT"')    else base::data.frame() })
isr_tbl  <- shiny::reactive({ if ("ISRCTN" %in% DBI::dbListTables(pool_con)) DBI::dbGetQuery(pool_con, 'SELECT * FROM "ISRCTN"') else base::data.frame() })
nihr_tbl <- shiny::reactive({ if ("NIHR"   %in% DBI::dbListTables(pool_con)) DBI::dbGetQuery(pool_con, 'SELECT * FROM "NIHR"')   else base::data.frame() })
eu_tbl   <- shiny::reactive({ if ("EU"     %in% DBI::dbListTables(pool_con)) DBI::dbGetQuery(pool_con, 'SELECT * FROM "EU"')     else base::data.frame() })

```
```{r}

# Put this in a setup/server chunk that runs before consumers

# 0) Choose a connection (adjust if you only have main_con)
con <- if (exists("pool_con", inherits = TRUE)) pool_con else main_con

# 1) Tiny util: safe run + neat section headers
.section <- function(title) {
  cat("\n", paste0(strrep("=", nchar(title)), "\n", title, "\n", strrep("=", nchar(title)), "\n"), sep = "")
}
.try <- function(expr, msg = NULL) {
  tryCatch(expr, error = function(e) { if (!is.null(msg)) cat(msg, "\n"); print(e); NULL })
}

# 2) Schema dump for a table: fields, PRAGMA, head, quick presence checks
dump_table_schema <- function(con, tbl, required = character(), head_n = 5L) {
  .section(paste0("TABLE: ", tbl))
  if (!(tbl %in% DBI::dbListTables(con))) {
    cat("! Table not found.\n")
    return(invisible(NULL))
  }

  # Fields
  flds <- DBI::dbListFields(con, tbl)
  cat("Fields:\n  - ", paste(flds, collapse = "\n  - "), "\n", sep = "")

  # PRAGMA table_info (types, pk, notnull)
  cat("\nPRAGMA table_info:\n")
  print(.try(DBI::dbGetQuery(con, paste0('PRAGMA table_info("', tbl, '");'))))

  # Head (quoted select to be safe)
  cat("\nHead (", head_n, " rows):\n", sep = "")
  sel <- paste0('SELECT * FROM "', tbl, '" LIMIT ', head_n, ';')
  print(.try(DBI::dbGetQuery(con, sel)))

  # Required columns present?
  if (length(required)) {
    cat("\nRequired columns check:\n")
    miss <- setdiff(required, flds)
    if (length(miss)) {
      cat("  MISSING: ", paste(miss, collapse = ", "), "\n", sep = "")
    } else {
      cat("  OK: all present\n")
    }
  }

  invisible(list(fields = flds))
}

# 3) Variant finder: return the first match present in table
find_first_present <- function(con, tbl, candidates) {
  flds <- DBI::dbListFields(con, tbl)
  hit <- candidates[candidates %in% flds]
  if (length(hit)) hit[[1]] else NA_character_
}

# 4) Quick probes for each registry (tweak required-cols if your tables differ)
# NCT
dump_table_schema(
  con, "NCT",
  required = c("Program","Guideline.number","Query_Date","NCTId","BriefTitle","OverallStatus")
)

# ISRCTN
dump_table_schema(
  con, "ISRCTN",
  required = c("Program","Guideline.number","Query_Date","ISRCTN_No","URL")
)

# NIHR
dump_table_schema(
  con, "NIHR",
  required = c("Program","Guideline.number","Query_Date","project_id","project_title","project_status")
)

# EU
dump_table_schema(
  con, "EU",
  required = c("Program","Guideline.number","Query_Date","EU_Ids","X_id","URL")
)

# 5) Discover actual column names for “variant” fields on ISRCTN (so SQL can COALESCE correctly)
.section("ISRCTN — Variant column discovery")
isr_title    <- find_first_present(con, "ISRCTN", c("Public_Title","primary_title"))
isr_sci      <- find_first_present(con, "ISRCTN", c("Scientific_Title","scientific_title"))
isr_status   <- find_first_present(con, "ISRCTN", c("Recruitment_Status","registration_status"))
isr_res_done <- find_first_present(con, "ISRCTN", c("Results_date_completed","results_date_completed"))
isr_res_url  <- find_first_present(con, "ISRCTN", c("Results_url_link","results_url_link"))
isr_res_sum  <- find_first_present(con, "ISRCTN", c("Results_summary","results_summary"))
cat(paste0(
  "Title: ", isr_title, "\n",
  "Scientific Title: ", isr_sci, "\n",
  "Recruitment Status: ", isr_status, "\n",
  "Results Completed date: ", isr_res_done, "\n",
  "Results URL: ", isr_res_url, "\n",
  "Results summary: ", isr_res_sum, "\n"
))

# 6) Optional: export everything to a file for sharing/debugging
export_schemas <- function(con, path = file.path(tempdir(), paste0("schema_dump_", Sys.Date(), ".txt"))) {
  conn <- file(path, open = "wt", encoding = "UTF-8")
  on.exit(close(conn), add = TRUE)
  sink(conn); on.exit(sink(), add = TRUE)
  dump_table_schema(con, "NCT")
  dump_table_schema(con, "ISRCTN")
  dump_table_schema(con, "NIHR")
  dump_table_schema(con, "EU")
  cat("\n-- Variant discovery (ISRCTN) --\n")
  cat(paste0(
    "Title=", isr_title, ", Sci=", isr_sci, ", Status=", isr_status,
    ", ResDone=", isr_res_done, ", ResURL=", isr_res_url, ", ResSummary=", isr_res_sum, "\n"
  ))
  path
}
# To export: export_schemas(con)
```

```{css, echo=FALSE}
#button_download_dbs.btn,
#downloadtemplate.btn {
  width: auto !important;
  min-width: 0;
}
```

Live Trial Info
======================================================

**`r textOutput("last_refreshed_txt_live", inline = TRUE)`**

Row {.tabset .tabset-fade}
--------------------------------------------------------

### ClinicalTrials.gov

```{r CTGlive}
DT::DTOutput("live_trial_table_nct")
```

### ISRCTN

```{r ISCTNlive}
DT::DTOutput("live_trial_table_isrctn")
```

### NIHR

```{r NIHRlive}
DT::DTOutput("live_trial_table_nihr")
```

### Clinicaltrials.eu

```{r EUlive}
DT::DTOutput("live_trial_table_eu")
```

Recent Status Changes
======================================================

**`r textOutput("last_refreshed_txt_recent", inline = TRUE)`**

**Changes are from 31 days ago**

Row {.tabset .tabset-fade}
--------------------------------------------------------

### ClinicalTrials.gov

```{r NCTmonthlychange}
DT::DTOutput("nct_monthly_change")
```

### ISRCTN

```{r ISRCTNmonthlychange}
DT::DTOutput("isrctn_monthly_change")
```

### NIHR

```{r NIHRmonthlychange}
DT::DTOutput("nihr_monthly_change")
```

### Clinicaltrials.eu

```{r Clinicaltrialseumonthlychange}
DT::DTOutput("clinicaltrialseu_monthly_change")
```

No Changes in Last 6m
======================================================

**`r textOutput("last_refreshed_txt_nochg", inline = TRUE)`**

Row {.tabset .tabset-fade}
--------------------------------------------------------

### ClinicalTrials.gov

```{r nochangeCTG}
DT::DTOutput("no_change_nct")
```

### ISRCTN

```{r nochangeISRCTN}
DT::DTOutput("no_change_isrctn")
```

### NIHR

```{r nochangeNIHR}
DT::DTOutput("no_change_nihr")
```

### Clinicaltrials.eu

```{r nochangeEU}
DT::DTOutput("no_change_cteu")
```

Pubmed Publications
======================================================

**`r textOutput("last_refreshed_txt_pub", inline = TRUE)`**

Row {.tabset .tabset-fade}
--------------------------------------------------------

### ClinicalTrials.gov

```{r CTGpubstable}
DT::DTOutput("pubmed_nct")
```

### ISRCTN

```{r ISRCTNpubstable}
DT::DTOutput("pubmed_isrctn")
```

### NIHR

```{r NIHRpubstable}
DT::DTOutput("pubmed_nihr")
```

### Clinicaltrials.eu

```{r EUpubstable}
DT::DTOutput("pubmed_eu")
```

Add/Remove Trials
======================================================

Row {.tabset .tabset-fade}
--------------------------------------------------------

### Add Trial

There are two ways to add trials:

1.  Add one at a time, choosing the relevant registry button, completing the guideline number, trial ID, and URL boxes, then pressing 'add trial'.
2.  Add more than one trial at once by uploading a spreadsheet containing relevant details using the 'choose file' box on the next tab.

**Note that Trial ID reference number must be in the correct format. Eg:**

-   Clinicaltrials.gov - "NCT03883230"
-   ISRCTN - "ISRCTN11735271"
-   NIHR - "14-158-02" or "14/158/02" or "RP-PG-0109-10056"
-   Clinicaltrials.eu - "2007-003673-21" (omit the last two letters designating country)

```{r AddTrialsSideBySide}

# One row with two columns. Uses Bootstrap 5 utilities (works with your theme).
shiny::fluidRow(
  class = "g-3",  # nice gutter spacing

  # =========================
  # LEFT: Add Single Trial
  # =========================
  shiny::column(
    width = 6,
    shiny::div(
      class = "d-flex",
      shiny::div(
        class = "card flex-fill mb-0",
        shiny::div(class = "card-header h5 mb-0", "Add Single Trial"),
        shiny::div(
          class = "card-body",
          shiny::radioButtons(
            "registry_add",
            label = "Select Registry",
            choices = c(
              "Clinicaltrials.gov" = "NCT_Ids",
              "ISRCTN"             = "ISRCTN_Ids",
              "NIHR"               = "NIHR_Ids",
              "Clinicaltrials.eu"  = "EU_Ids"
            )
          ),
          shiny::selectInput(
            "guideline_program_add",
            label   = "Enter program description",
            choices = c("COVID", "IP", "Other"),
            selected = "COVID"
          ),
          shiny::textInput(
            "guideline_reference_add",
            label = "Enter guideline number(s)",
            placeholder = "e.g. CG179"
          ),
          shiny::textInput(
            "ID_add",
            label = "Enter Trial ID reference number",
            placeholder = "e.g. NCT03597750"
          ),
          shiny::textInput(
            "URL_add",
            label = "Paste URL to trial page in registry",
            placeholder = "e.g. https://clinicaltrials.gov/ct2/show/NCT03597750"
          ),
          shiny::actionButton("button_add",
                              label = "Add single trial",
                              icon  = shiny::icon("plus-circle"),
                              class = "btn btn-primary"),
          shiny::div(class = "mt-2", shiny::uiOutput("single_result"))
        )
      )
    )
  ),

  # =========================
  # RIGHT: Add Multiple Trials
  # =========================
  shiny::column(
    width = 6,
    shiny::div(
      class = "d-flex",
      shiny::div(
        class = "card flex-fill mb-0",
        shiny::div(class = "card-header h5 mb-0", "Add Multiple Trials via CSV File"),
        shiny::div(
          class = "card-body",
          # compact, non-stretching download button
          shiny::tags$div(
            class = "d-inline-block mb-2",
            shiny::downloadButton(
              "downloadtemplate",
              label = "Download template",
              class = "btn btn-secondary btn-sm"
            )
          ),
          shiny::fileInput(
            "uploadtemplate",
            label = "Upload completed template",
            multiple = FALSE,
            accept = ".csv"
          ),
          shiny::actionButton("button_add_multi",
                              label = "Add trial spreadsheet",
                              icon  = shiny::icon("file-upload"),
                              class = "btn btn-primary"),
          shiny::div(
            class = "mt-3",
            shiny::uiOutput("multi_result"),
            shiny::textOutput("multi_error"),
            shiny::textOutput("multi_fail"),
            shiny::textOutput("multi_success")
          )
        )
      )
    )
  )
)
```

### Remove or Archive Trial

Select relevant registry and trial ID reference number below, along with any archiving comments.

'Archiving' moves the trial information from the live lists to the relevant archived trials list, where it will no longer be updated. 'Deleting' will remove the trial from the live lists and information will not be stored

```{r Removetab}

shiny::fluidRow(class = "g-3", shiny::column(width = 12, shiny::div(
  class = "card",
  shiny::div(class = "card-header h5 mb-0", "Remove or Archive Trial"),
  shiny::div(
    class = "card-body",
    
    # Inputs
    shiny::fluidRow(
      shiny::column(
        width = 4,
        shiny::radioButtons(
          "registry_remove",
          label = "Registry",
          choices = c(
            "Clinicaltrials.gov" = "NCT_Ids",
            "ISRCTN"             = "ISRCTN_Ids",
            "NIHR"               = "NIHR_Ids",
            "Clinicaltrials.eu"  = "EU_Ids"
          )
        )
      ),
      shiny::column(
        width = 8,
        shiny::selectInput("ID_remove", label = "Select Trial ID reference number", choices = ""),
        shiny::textAreaInput(
          "comments_archive",
          label = "Archive Comments",
          placeholder = "Optional notes for the archive record…",
          rows = 2,
          resize = "vertical"
        )
      )
    ),
    
    # Actions (compact, consistent sizing)
    shiny::div(
      class = "d-flex gap-2 mt-2 flex-wrap",
      shiny::actionButton(
        "button_delete",
        "Delete trial",
        icon  = shiny::icon("trash"),
        class = "btn btn-danger btn-sm"
      ),
      shiny::actionButton(
        "button_archive",
        "Archive trial",
        icon  = shiny::icon("archive"),
        class = "btn btn-warning btn-sm"
      ),
      shiny::downloadButton(
        "button_download_dbs",
        label = "Download SQLite data",
        class = "btn btn-secondary btn-sm"
      )
    )
    ,
    
    # Messages
    shiny::div(
      class = "mt-2",
      shiny::textOutput("success_delete"),
      shiny::textOutput("success_archive")
    )
  )
)))
```

Archived Trials
======================================================

Row {.tabset .tabset-fade}
--------------------------------------------------------

### ClinicalTrials.gov Archive

```{r CG.govarchive}

DBI::dbReadTable(pool_con, "NCT_rxv") |>
  dplyr::mutate(across(.cols = everything(), .fns = clean_utf8),
    `Archive Date` = lubridate::as_date(as.numeric(Query_Date))
  ) |>
  dplyr::select(
    -SeeAlsoLinkURL,
    -Query_Date
  ) |>
  dplyr::select(`Archive Date`,
    everything(),
    `Archiving Comments` = Archiving_Comments
  ) |>
  dplyr::rename(
    "Guideline" = Guideline.number,
    `NCT ID` = NCTId,
    `Org Study ID` = OrgStudyId,
    Title = BriefTitle,
    Status = OverallStatus,
    `Primary Completion Date` = PrimaryCompletionDate,
    `Completion Date` = CompletionDate,
    `Results Submit Date` = ResultsFirstSubmitDate,
    `Results Post Date` = ResultsFirstPostDate,
    `Last Update` = LastUpdatePostDate
  ) |>
  dplyr::distinct() |>
  DT::datatable(options = list(bPaginate = FALSE, scrollY = TRUE), filter = "top")
```

### ISRCTN Archive

```{r ISRCTNarchivetable}

DBI::dbReadTable(pool_con, "ISRCTN_rxv") |>
  dplyr::mutate(across(.cols = everything(), .fns = clean_utf8),
    `Archive Date` = lubridate::as_date(as.numeric(Query_Date))
  ) |>
  dplyr::select(-Query_Date) |>
  dplyr::select(
    `Archive Date`,
    everything()
  ) |>
  dplyr::rename(
    "Program or Guideline" = Guideline.number,
    `ISRCTN ID` = ISRCTN_No,
    Title = Public_Title,
    `Scientific Title` = Scientific_Title,
    `Recruitment Status` = Recruitment_Status,
    `Results completed date` = Results_date_completed,
    `Results URL` = Results_url_link,
    `Results summary` = Results_summary,
    `Results posted date` = Results_date_posted,
    `Results published date` = Results_date_first_publication,
    `Archiving Comments` = Archiving_Comments
  ) |>
  dplyr::distinct() |>
  DT::datatable(options = list(bPaginate = FALSE, scrollY = TRUE), filter = "top")

```

### NIHR Archive

```{r NIHRarchivetable}

DBI::dbReadTable(pool_con, "NIHR_rxv") |>
  dplyr::mutate(across(.cols = everything(), .fns = clean_utf8),
    `Archive Date` = lubridate::as_date(as.numeric(Query_Date))
  ) |>
  dplyr::select(-Query_Date) |>
  dplyr::select(
    `Archive Date`,
    everything()
  ) |>
  dplyr::rename(
    "Program or Guideline" = Guideline.number,
    `NIHR ID` = project_id,
    `Project Title` = project_title,
    Status = project_status,
    `End Date` = end_date,
    `Archiving Comments` = Archiving_Comments
  ) |>
  dplyr::distinct() |>
  DT::datatable(options = list(bPaginate = FALSE, scrollY = TRUE), filter = "top")
```

### EU Archive

```{r EUarchivetable}

DBI::dbReadTable(pool_con, "EU_rxv") |>
  dplyr::select(-a31_title_of_the_trial_for_lay_people_in_easily_understood_ie_nontechnical_language, -EU_Ids) |>
  dplyr::mutate(across(.cols = everything(), .fns = clean_utf8),
    `Archive Date` = lubridate::as_date(as.numeric(Query_Date))
  ) |>
  dplyr::select(-Query_Date) |>
  dplyr::rename(
    "Program or Guideline" = Guideline.number,
    `Clinicaltrials.eu ID` = `X_id`,
    `End of Trial Status` = p_end_of_trial_status,
    Title = a3_full_title_of_the_trial,
    `Abbreviated Title` = a32_name_or_abbreviated_title_of_the_trial_where_available,
    `Sponsor ID` = a41_sponsors_protocol_code_number,
    `Archiving Comments` = Archiving_Comments
  ) |>
  dplyr::distinct() |>
  DT::datatable(options = list(bPaginate = FALSE, scrollY = TRUE), filter = "top")
```

```{r ServerCodeUpdates, context = "server", echo = FALSE}

# Helper to render a "last refreshed" string into a given output ID
render_last_refreshed <- function(id) {
  output[[id]] <- shiny::renderText({
    ts <- mtime_reader()
    if (base::is.na(ts)) return("Unknown")
    utc <- base::format(ts, "%Y-%m-%d %H:%M", tz = "UTC")
    paste0("🔄 Last refreshed at: ", utc, " UTC")
  })
}

# Create multiple refresh outputs for each page
render_last_refreshed("last_refreshed_txt_live")
render_last_refreshed("last_refreshed_txt_recent")
render_last_refreshed("last_refreshed_txt_nochg")
render_last_refreshed("last_refreshed_txt_pub")

# Central refresh function
refresh_all_data <- function() {
  
  #Call Update Script
  trialtracker::download_trial_info_wrapper_no_pm_or_email()

  # UI to see the new mtime
  invalidate_cache()
}

```

```{r ServerLiveTrialInfo, context = "server", echo = FALSE}

# --- NCT latest (reactive data) ---
nct_latest_df <- shiny::reactive({
  base_sql <- latest_sql("NCT", "NCTId")
  .with_temp_ids(pool_con, "_tmp_nct_ids", "NCTId", nct_ids(), function(has_ids) {
    if (has_ids) {
      DBI::dbGetQuery(pool_con, glue::glue("
        WITH latest AS ({base_sql})
        SELECT Program,
               `Guideline.number` AS Guideline,
               DATE(Query_Date)   AS `Query Date`,
               NCTId              AS `NCT ID`,
               BriefTitle         AS Title,
               OverallStatus      AS Status
        FROM latest JOIN _tmp_nct_ids USING(NCTId)
        ORDER BY `Query Date` DESC, `NCT ID`
      "))
    } else {
      DBI::dbGetQuery(pool_con, glue::glue("
        SELECT Program, `Guideline.number` AS Guideline, DATE(Query_Date) AS `Query Date`,
               NCTId AS `NCT ID`, BriefTitle AS Title, OverallStatus AS Status
        FROM ({base_sql})
        ORDER BY `Query Date` DESC, `NCT ID`
      "))
    }
  })
}) |>
  shiny::bindCache(mtime_reader(), nct_ids()) |>
  shiny::bindEvent(mtime_reader())

output$live_trial_table_nct <- DT::renderDT({
  df <- nct_latest_df()
  if (!base::nrow(df)) return(df)
  df |> dplyr::mutate(Title = fast_trunc(.data[["Title"]], 120L))
}, options = dt_opts_server, server = TRUE, filter = "top")

## --- ISRCTN “Latest” SQL builder (non-reactive) ---
isr_latest_sql_from_trial_ids <- function(con) {
  glue::glue_sql("
WITH
  ids AS (
    SELECT DISTINCT TRIM(\"ISRCTN_Ids\") AS \"ISRCTN_No\"
    FROM \"Trial_Ids\"
    WHERE \"ISRCTN_Ids\" IS NOT NULL AND TRIM(\"ISRCTN_Ids\") <> ''
  ),
  base AS (
    SELECT i.*
    FROM \"ISRCTN\" i
    JOIN ids USING (\"ISRCTN_No\")
  ),
  latest_rank AS (
    SELECT base.*,
           ROW_NUMBER() OVER (PARTITION BY \"ISRCTN_No\" ORDER BY \"Query_Date\" DESC) AS rn
    FROM base
  ),
  latest AS (SELECT * FROM latest_rank WHERE rn = 1),
  first_seen AS (
    SELECT \"ISRCTN_No\", DATE(MIN(\"Query_Date\")) AS \"Date Added\"
    FROM base
    GROUP BY \"ISRCTN_No\"
  )
SELECT
  latest.\"Program\"                      AS \"Program\",
  latest.\"Guideline.number\"             AS \"Guideline\",
  first_seen.\"Date Added\"               AS \"Date Added\",
  latest.\"URL\"                          AS \"URL\",
  latest.\"ISRCTN_No\"                    AS \"ISRCTN ID\",
  latest.\"Public_Title\"                 AS \"Title\",
  latest.\"Acronym\"                      AS \"Acronym\",
  latest.\"Scientific_Title\"             AS \"Scientific Title\",
  latest.\"Recruitment_Status\"           AS \"Recruitment Status\",
  latest.\"Results_date_completed\"       AS \"Results Completed Date\",
  latest.\"Results_url_link\"             AS \"Results URL Link\",
  latest.\"Results_summary\"              AS \"Results Summary\",
  latest.\"Results_date_posted\"          AS \"Results Posted Date\",
  latest.\"Results_date_first_publication\" AS \"Results Published Date\"
FROM latest
JOIN first_seen USING (\"ISRCTN_No\")
ORDER BY \"Date Added\" DESC, \"ISRCTN ID\";
", .con = con)
}

# --- Execute inside renderDT (reactivity happens here) ---
output$live_trial_table_isrctn <- DT::renderDT({
  sql <- isr_latest_sql_from_trial_ids(pool_con)
  df  <- DBI::dbGetQuery(pool_con, sql)
  if (!base::nrow(df)) base::return(df)
  df
}, options = dt_opts_server, server = TRUE, filter = "top")

# --- NIHR latest (reactive data) ---
nihr_latest_df <- shiny::reactive({
  base_sql <- latest_sql("NIHR", "project_id")
  .with_temp_ids(pool_con, "_tmp_nihr_ids", "project_id", nihr_ids(), function(has_ids) {
    if (has_ids) {
      DBI::dbGetQuery(pool_con, glue::glue("
        WITH latest AS ({base_sql})
        SELECT Program,
               `Guideline.number` AS Guideline,
               DATE(Query_Date)   AS `Query Date`,
               project_id         AS `NIHR ID`,
               project_title      AS `Project Title`,
               project_status     AS Status,
               end_date           AS `End Date`
        FROM latest JOIN _tmp_nihr_ids USING(project_id)
        ORDER BY `Query Date` DESC, `NIHR ID`
      "))
    } else {
      DBI::dbGetQuery(pool_con, glue::glue("
        SELECT Program, `Guideline.number` AS Guideline, DATE(Query_Date) AS `Query Date`,
               project_id AS `NIHR ID`, project_title AS `Project Title`,
               project_status AS Status, end_date AS `End Date`
        FROM ({base_sql})
        ORDER BY `Query Date` DESC, `NIHR ID`
      "))
    }
  })
}) |>
  shiny::bindCache(mtime_reader(), nihr_ids()) |>
  shiny::bindEvent(mtime_reader())

output$live_trial_table_nihr <- DT::renderDT({
  nihr_latest_df()
}, options = dt_opts_server, server = TRUE, filter = "top")


# --- EU latest (reactive data) ---
eu_latest_df <- shiny::reactive({
  base_sql <- latest_sql("EU", "EU_Ids")
  .with_temp_ids(pool_con, "_tmp_eu_ids", "EU_Ids", eu_ids(), function(has_ids) {
    if (has_ids) {
      DBI::dbGetQuery(pool_con, glue::glue("
        WITH latest AS ({base_sql})
        SELECT Program,
               `Guideline.number` AS Guideline,
               DATE(Query_Date)   AS `Query Date`,
               EU_Ids             AS `EU ID`,
               X_id               AS `Clinicaltrials.eu ID`,
               a3_full_title_of_the_trial AS Title,
               a32_name_or_abbreviated_title_of_the_trial_where_available AS `Abbreviated Title`,
               p_end_of_trial_status AS `End of Trial Status`,
               a41_sponsors_protocol_code_number AS `Sponsor ID`,
               URL
        FROM latest JOIN _tmp_eu_ids USING(EU_Ids)
        ORDER BY `Query Date` DESC, `EU ID`
      "))
    } else {
      DBI::dbGetQuery(pool_con, glue::glue("
        SELECT Program, `Guideline.number` AS Guideline, DATE(Query_Date) AS `Query Date`,
               EU_Ids AS `EU ID`, X_id AS `Clinicaltrials.eu ID`,
               a3_full_title_of_the_trial AS Title,
               a32_name_or_abbreviated_title_of_the_trial_where_available AS `Abbreviated Title`,
               p_end_of_trial_status AS `End of Trial Status`,
               a41_sponsors_protocol_code_number AS `Sponsor ID`,
               URL
        FROM ({base_sql})
        ORDER BY `Query Date` DESC, `EU ID`
      "))
    }
  })
}) |>
  shiny::bindCache(mtime_reader(), eu_ids()) |>
  shiny::bindEvent(mtime_reader())

output$live_trial_table_eu <- DT::renderDT({
  df <- eu_latest_df()
  if (!base::nrow(df)) return(df)
  df |> dplyr::mutate(Title = fast_trunc(.data[["Title"]], 120L))
}, options = dt_opts_server, server = TRUE, filter = "top")

```

```{r ServerRecentStatusChanges, context="server", echo = FALSE}

build_diff_sql <- function(table, id_col, label_cols, meta, diff_map, ctx_map, cutoff_date, ids_tmp) {
  label_cols <- gsub("`", "", label_cols, fixed = TRUE)
  id_col     <- gsub("`", "", id_col,     fixed = TRUE)
  table      <- gsub("`", "", table,      fixed = TRUE)

  label_cols_plus <- c(label_cols, "Date Added")

  coalesce_label <- function(col) {
    if (col == "Date Added") sprintf('base."%s" AS "%s"', col, col)
    else sprintf('COALESCE(%s, %s) AS "%s"', .qq("n", col), .qq("o", col), col)
  }
  labels_sql <- paste(vapply(label_cols_plus, coalesce_label, character(1)), collapse = ",\n           ")

  meta_part <- function(src, out) {
    if (is.null(meta[[src]])) sprintf('NULL AS "%s",', out)
    else sprintf('COALESCE(%s, %s) AS "%s",', .qq("n", meta[[src]]), .qq("o", meta[[src]]), out)
  }
  meta_url   <- meta_part("url","URL")
  meta_acr   <- meta_part("acronym","Acronym")
  meta_title <- meta_part("title","Title")
  meta_cond  <- meta_part("condition","Condition")

  ctx_select <- function(side = "n") {
    if (!length(ctx_map)) return("")
    paste(vapply(seq_along(ctx_map), function(i) {
      sprintf('%s AS "%s"', .qq(side, names(ctx_map)[i]), unname(ctx_map)[i])
    }, character(1)), collapse = ",\n           ")
  }

  diff_select_for <- function(side, which_src) {
    paste(vapply(seq_along(diff_map), function(i) {
      src <- names(diff_map)[i]; alias <- unname(diff_map)[i]
      if (identical(src, which_src)) sprintf('%s AS "%s"', .qq(side, src), alias)
      else                           sprintf('NULL AS "%s"', alias)
    }, character(1)), collapse = ",\n           ")
  }

  unions <- paste(vapply(names(diff_map), function(src) {
    alias <- diff_map[[src]]
    paste0(
      "SELECT '+' AS Change, '", alias, "' AS \"Changed Field\", ", labels_sql, ",\n",
      "       ", meta_url, "\n       ", meta_acr, "\n       ", meta_title, "\n       ", meta_cond, "\n",
      "       ", diff_select_for("n", src),
      if (length(ctx_map)) paste0(",\n       ", ctx_select("n")) else "",
      ",\n       DATE(", .qq("n","Query_Date"), ") AS `When`, COALESCE(", .qq("n", id_col), ", ", .qq("o", id_col), ') AS "', id_col, "\"\n",
      "FROM base WHERE (", .qq("n", src), " IS NOT ", .qq("o", src), ")\nUNION ALL\n",
      "SELECT '-' AS Change, '", alias, "' AS \"Changed Field\", ", labels_sql, ",\n",
      "       ", meta_url, "\n       ", meta_acr, "\n       ", meta_title, "\n       ", meta_cond, "\n",
      "       ", diff_select_for("o", src),
      if (length(ctx_map)) paste0(",\n       ", ctx_select("n")) else "",
      ",\n       DATE(", .qq("o","Query_Date"), ") AS `When`, COALESCE(", .qq("n", id_col), ", ", .qq("o", id_col), ') AS "', id_col, "\"\n",
      "FROM base WHERE (", .qq("n", src), " IS NOT ", .qq("o", src), ")"
    )
  }, character(1)), collapse = "\nUNION ALL\n")

  ctx_nulls <- if (length(ctx_map)) paste(rep("NULL", length(ctx_map)), collapse = ", ") else ""
  ctx_news  <- ctx_select("n")
  diff_nulls<- paste(rep("NULL", length(diff_map)), collapse = ", ")
  ctx_news_clause  <- if (nzchar(ctx_news))  paste0(", ", ctx_news) else ""
  ctx_nulls_clause <- if (nzchar(ctx_nulls)) paste0(", ", ctx_nulls) else ""

  glue::glue(
"WITH
  ids AS (SELECT \"{id_col}\" FROM {ids_tmp}),
  n_rank AS (
    SELECT t.*, ROW_NUMBER() OVER (PARTITION BY \"{id_col}\" ORDER BY \"Query_Date\" DESC) rn
    FROM \"{table}\" t JOIN ids USING(\"{id_col}\")
  ),
  n AS (SELECT * FROM n_rank WHERE rn = 1),
  o_rank AS (
    SELECT t.*, ROW_NUMBER() OVER (PARTITION BY \"{id_col}\" ORDER BY \"Query_Date\" DESC) rn
    FROM \"{table}\" t JOIN ids USING(\"{id_col}\")
    WHERE DATE(t.\"Query_Date\") <= DATE('{cutoff_date}')
  ),
  o AS (SELECT * FROM o_rank WHERE rn = 1),
  first_seen AS (
    SELECT \"{id_col}\", DATE(MIN(\"Query_Date\")) AS \"Date Added\"
    FROM \"{table}\" JOIN ids USING(\"{id_col}\")
    GROUP BY \"{id_col}\"
  ),
  base AS (
    SELECT fs.\"Date Added\", n.*, o.*
    FROM n
    LEFT JOIN o  USING(\"{id_col}\")
    LEFT JOIN first_seen fs USING(\"{id_col}\")
    UNION ALL
    SELECT fs.\"Date Added\", n.*, o.*
    FROM o
    LEFT JOIN n USING(\"{id_col}\")
    LEFT JOIN first_seen fs USING(\"{id_col}\")
    WHERE ", .qq("n", id_col), " IS NULL
  )
{unions}
UNION ALL
SELECT '+' AS Change, 'Added' AS \"Changed Field\", {labels_sql}, {meta_url} {meta_acr} {meta_title} {meta_cond} {diff_nulls}{ctx_news_clause},
       DATE(", .qq("n","Query_Date"), ") AS `When`, ", .qq("n", id_col), " AS \"{id_col}\"
FROM base WHERE ", .qq("o", id_col), " IS NULL
UNION ALL
SELECT '-' AS Change, 'Removed' AS \"Changed Field\", {labels_sql}, {meta_url} {meta_acr} {meta_title} {meta_cond} {diff_nulls}{ctx_nulls_clause},
       DATE(", .qq("o","Query_Date"), ") AS `When`, ", .qq("o", id_col), " AS \"{id_col}\"
FROM base WHERE ", .qq("n", id_col), " IS NULL
ORDER BY `When` DESC, \"{id_col}\";"
  )
}

run_diff <- function(cfg, ids, cutoff_date) {
  if (!base::length(ids)) return(base::data.frame())
  tmp <- base::paste0("_tmp_ids_", cfg$id_col, "_", base::as.integer(stats::runif(1, 1e6, 9e6)))
  DBI::dbExecute(pool_con, glue::glue("DROP TABLE IF EXISTS {tmp};"))
  DBI::dbExecute(pool_con, glue::glue('CREATE TEMP TABLE {tmp} ("{cfg$id_col}" TEXT PRIMARY KEY);'))
  DBI::dbWriteTable(pool_con, tmp, stats::setNames(base::data.frame(ids, check.names = FALSE), cfg$id_col), append = TRUE)
  on.exit(DBI::dbExecute(pool_con, glue::glue("DROP TABLE IF EXISTS {tmp};")), add = TRUE)
  sql <- build_diff_sql(cfg$table, cfg$id_col, cfg$label_cols, cfg$meta, cfg$diff_map, cfg$ctx_map, cutoff_date, tmp)
  DBI::dbGetQuery(pool_con, sql)
}

cutoff_date <- base::Sys.Date() - 31L

configs <- list(
  list( # NCT
    output_id  = "nct_monthly_change",
    table      = "NCT",
    id_col     = "NCTId",
    id_label   = "NCT ID",
    label_cols = c("Program","Guideline.number"),
    meta       = list(url="URL", acronym="Acronym", title="BriefTitle", condition="Condition"),
    diff_map   = c(OverallStatus="Status", CompletionDate="Completion Date", LastUpdatePostDate="Last Update Date"),
    ctx_map    = c(ResultsFirstSubmitDate="Results Submit Date"),
    ids_get    = nct_ids,
    post_mutate= function(df, id_col){
      df |>
        dplyr::mutate(
          URL = base::paste0("https://clinicaltrials.gov/ct2/show/", .data[[id_col]]),
          Title = fast_trunc(.data[["Title"]], 80L),
          Condition = fast_trunc(.data[["Condition"]], 30L),
          `Completion Date`     = base::suppressWarnings(lubridate::as_date(lubridate::parse_date_time(`Completion Date`,     c("ymd","bdy"), truncated = 1))),
          `Results Submit Date` = base::suppressWarnings(lubridate::as_date(lubridate::parse_date_time(`Results Submit Date`, c("ymd","bdy"), truncated = 1))),
          `Last Update Date`    = base::suppressWarnings(lubridate::as_date(lubridate::parse_date_time(`Last Update Date`,    c("ymd","bdy"), truncated = 1)))
        )
    },
    final_cols = c("Change","Changed Field","Program","Guideline","Date Added","URL","Acronym","Title","Condition","Status","Completion Date","Results Submit Date","Last Update Date")
  ),
  list( # ISRCTN
    output_id  = "isrctn_monthly_change",
    table      = "ISRCTN",
    id_col     = "ISRCTN_No",
    id_label   = "ISRCTN",
    label_cols = c("Program","Guideline.number"),
    meta       = list(url="URL", acronym="Acronym", title="Scientific_Title", condition=NULL),
    diff_map   = c(
      Recruitment_Status="Recruitment Status",
      Results_url_link="Results URL",
      Results_summary="Results Summary",
      Results_date_completed="Results Completed",
      Results_date_posted="Results Posted",
      Results_date_first_publication="Results Published"
    ),
    ctx_map    = character(0),
    ids_get    = isr_ids,
    post_mutate= function(df, id_col){
      df |>
        dplyr::mutate(
          Title = fast_trunc(.data[["Title"]], 75L),
          `Results Completed` = base::suppressWarnings(lubridate::dmy(`Results Completed`)),
          `Results Posted`    = base::suppressWarnings(lubridate::dmy(`Results Posted`)),
          `Results Published` = base::suppressWarnings(lubridate::dmy(`Results Published`))
        )
    },
    final_cols = c("Change","Changed Field","Program","Guideline","Date Added","URL","Acronym","Title","Recruitment Status","Results URL","Results Summary","Results Completed","Results Posted","Results Published")
  ),
  list( # NIHR
    output_id  = "nihr_monthly_change",
    table      = "NIHR",
    id_col     = "project_id",
    id_label   = "NIHR ID",
    label_cols = c("Program","Guideline.number"),
    meta       = list(url="URL", acronym=NULL, title="project_title", condition=NULL),
    diff_map   = c(project_status="Status", end_date="End Date"),
    ctx_map    = character(0),
    ids_get    = nihr_ids,
    post_mutate= function(df, id_col){ df |> dplyr::mutate(Title = fast_trunc(.data[["Title"]], 90L)) },
    final_cols = c("Change","Changed Field","Program","Guideline","Date Added","URL","NIHR ID","Title","Status","End Date")
  ),
  list( # EU
    output_id  = "clinicaltrialseu_monthly_change",
    table      = "EU",
    id_col     = "EU_Ids",
    id_label   = "EU ID",
    label_cols = c("Program","Guideline.number"),
    meta       = list(url="URL", acronym="a32_name_or_abbreviated_title_of_the_trial_where_available", title="a3_full_title_of_the_trial", condition=NULL),
    diff_map   = c(p_end_of_trial_status="End of Trial Status"),
    ctx_map    = c(a32_name_or_abbreviated_title_of_the_trial_where_available="Acronym", a3_full_title_of_the_trial="Title"),
    ids_get    = eu_ids,
    post_mutate= function(df, id_col){ df |> dplyr::mutate(Title = fast_trunc(.data[["Title"]], 90L)) },
    final_cols = c("Change","Changed Field","Program","Guideline","Date Added","URL","EU ID","End of Trial Status","Acronym","Title")
  )
)

# Cached producers + renderers (unchanged shape)
base::lapply(configs, function(cfg){
  local({
    cfg2 <- cfg
    data_rx <- shiny::reactive({
      ids <- cfg2$ids_get()
      run_diff(cfg2, ids, cutoff_date)
    }) |>
      shiny::bindCache(mtime_reader(), cfg2$ids_get()) |>
      shiny::bindEvent(mtime_reader())

    output[[cfg2$output_id]] <- DT::renderDT({
      df <- data_rx()
      if (!base::nrow(df)) base::return(df)
      id_sym <- rlang::sym(cfg2$id_col)
      df |>
        dplyr::rename(Guideline = .data[["Guideline.number"]]) |>
        dplyr::rename(!!cfg2$id_label := !!id_sym) |>
        cfg2$post_mutate(cfg2$id_col) |>
        dplyr::select(dplyr::all_of(cfg2$final_cols)) |>
        dplyr::distinct()
    }, options = dt_opts_server, server = TRUE, filter = "top")
  })
  NULL
})

```

```{r ServerNoChangesInLast6M, context = "server", echo = FALSE}

# Helper
generate_nochange_table <- function(
  data,
  id_col,
  rename_list,
  drop_cols    = NULL,
  reorder_cols = NULL,
  date_cols    = NULL,
  extra_mutate = NULL
) {
  req(data)
  data <- dplyr::mutate(data, Query_Date = lubridate::as_date(Query_Date))

  max_date <- max(data$Query_Date, na.rm = TRUE)
  cutoff   <- lubridate::add_with_rollback(max_date, -lubridate::period(months = 6L))
  older_ok <- data$Query_Date <= cutoff

  old_date <- if (any(older_ok, na.rm = TRUE)) max(data$Query_Date[older_ok], na.rm = TRUE) else as.Date(NA)

  current <- dplyr::filter(data, Query_Date == max_date)
  old     <- if (is.na(old_date)) dplyr::slice(current, 0) else dplyr::filter(data, Query_Date == old_date)

  date_added <- data |>
    dplyr::summarise(`Date Added` = lubridate::as_date(min(Query_Date - 1L)), .by = {{ id_col }})

  by_cols <- setdiff(intersect(names(current), names(old)), "Query_Date")

  joined <- dplyr::inner_join(
      current, old,
      by = by_cols,
      suffix = c(".cur", ".old")
    ) |>
    dplyr::select(-dplyr::ends_with(".cur"), -dplyr::ends_with(".old")) |>
    dplyr::left_join(date_added, by = rlang::as_string(rlang::ensym(id_col))) |>
    dplyr::mutate(dplyr::across(dplyr::everything(), clean_utf8))

  if (!is.null(date_cols) && nrow(joined) > 0) {
    joined <- dplyr::mutate(
      joined,
      dplyr::across(
        dplyr::all_of(date_cols),
        ~ lubridate::as_date(lubridate::parse_date_time(.x, c("ymd", "bdy", "dmy"), truncated = 1))
      )
    )
  }

  if (is.function(extra_mutate)) joined <- extra_mutate(joined)
  if (!is.null(drop_cols))       joined <- dplyr::select(joined, -dplyr::any_of(drop_cols))

  joined <- dplyr::rename(joined, !!!rename_list)
  if (!is.null(reorder_cols)) joined <- dplyr::select(joined, dplyr::all_of(reorder_cols))

  dplyr::distinct(joined)
}

# Cached data producers
nct_nochange_df <- shiny::reactive({
  generate_nochange_table(
    data = nct_tbl(),
    id_col = NCTId,
    rename_list = c(
      "Guideline" = "Guideline.number",
      `NCT ID` = "NCTId",
      `Org Study ID` = "OrgStudyId",
      Title = "BriefTitle",
      Status = "OverallStatus",
      `Primary Completion Date` = "PrimaryCompletionDate",
      `Completion Date` = "CompletionDate",
      `Results Submit Date` = "ResultsFirstSubmitDate",
      `Results Post Date` = "ResultsFirstPostDate",
      `Last Update` = "LastUpdatePostDate"
    ),
    drop_cols = "SeeAlsoLinkURL",
    reorder_cols = c(
      "Program","Guideline","Date Added","NCT ID","Org Study ID","Title","Status",
      "Primary Completion Date","Completion Date","Results Submit Date","Results Post Date","Last Update"
    ),
    date_cols = c(
      "PrimaryCompletionDate","CompletionDate","ResultsFirstSubmitDate","ResultsFirstPostDate","LastUpdatePostDate"
    )
  )
}) |> shiny::bindCache(mtime_reader()) |> shiny::bindEvent(mtime_reader())
isrctn_nochange_df <- shiny::reactive({
  generate_nochange_table(
    data = isr_tbl(),
    id_col = ISRCTN_No,
    rename_list = c(
      "Guideline" = "Guideline.number",
      `ISRCTN ID` = "ISRCTN_No",
      Title = "Public_Title",
      `Scientific Title` = "Scientific_Title",
      `Recruitment Status` = "Recruitment_Status",
      `Results completed date` = "Results_date_completed",
      `Results URL` = "Results_url_link",
      `Results summary` = "Results_summary",
      `Results posted date` = "Results_date_posted",
      `Results published date` = "Results_date_first_publication"
    ),
    reorder_cols = c(
      "Program","Guideline","Date Added","ISRCTN ID","Title","Scientific Title",
      "Recruitment Status","Results URL","Results summary",
      "Results completed date","Results posted date","Results published date"
    ),
    extra_mutate = ~ dplyr::mutate(.,
      Results_date_completed = lubridate::dmy(Results_date_completed),
      Results_date_posted = lubridate::dmy(Results_date_posted),
      Results_date_first_publication = lubridate::dmy(Results_date_first_publication)
    )
  )
}) |> shiny::bindCache(mtime_reader()) |> shiny::bindEvent(mtime_reader())
nihr_nochange_df <- shiny::reactive({
  generate_nochange_table(
    data = nihr_tbl(),
    id_col = project_id,
    rename_list = c(
      "Guideline" = "Guideline.number",
      `NIHR ID` = "project_id",
      `Project Title` = "project_title",
      Status = "project_status",
      `End Date` = "end_date"
    ),
    reorder_cols = c("Program","Guideline","Date Added","NIHR ID","Project Title","Status","End Date")
  )
}) |> shiny::bindCache(mtime_reader()) |> shiny::bindEvent(mtime_reader())
eu_nochange_df <- shiny::reactive({
  generate_nochange_table(
    data = eu_tbl() |> dplyr::select(
      -a31_title_of_the_trial_for_lay_people_in_easily_understood_ie_nontechnical_language,
      -EU_Ids
    ),
    id_col = X_id,
    rename_list = c(
      "Guideline" = "Guideline.number",
      `Clinicaltrials.eu ID` = "X_id",
      `End of Trial Status` = "p_end_of_trial_status",
      Title = "a3_full_title_of_the_trial",
      `Abbreviated Title` = "a32_name_or_abbreviated_title_of_the_trial_where_available",
      `Sponsor ID` = "a41_sponsors_protocol_code_number"
    ),
    reorder_cols = c(
      "Program","Guideline","Date Added","Clinicaltrials.eu ID","Title",
      "Abbreviated Title","End of Trial Status","Sponsor ID"
    )
  )
}) |> shiny::bindCache(mtime_reader()) |> shiny::bindEvent(mtime_reader())

# Renderers 
output$no_change_nct <- DT::renderDT({
  nct_nochange_df()
}, options = base::list(bPaginate = FALSE, scrollY = TRUE), server = TRUE, filter = "top")

output$no_change_isrctn <- DT::renderDT({
  isrctn_nochange_df()
}, options = base::list(bPaginate = FALSE, scrollY = TRUE), server = TRUE, filter = "top")

output$no_change_nihr <- DT::renderDT({
  nihr_nochange_df()
}, options = base::list(bPaginate = FALSE, scrollY = TRUE), server = TRUE, filter = "top")

output$no_change_cteu <- DT::renderDT({
  eu_nochange_df()
}, options = base::list(bPaginate = FALSE, scrollY = TRUE), server = TRUE, filter = "top")

```

```{r ServerPubMed, context = "server", echo = FALSE}

render_pubmed_table <- function(df) {
  if (!base::nrow(df)) return(df)
  out <- df |>
    dplyr::mutate(
      dplyr::across(where(base::is.character), ~ base::enc2utf8(base::as.character(.x))),
      Query_Date   = base::suppressWarnings(base::as.Date(.data[["Query_Date"]])),
      `Query Date` = base::format(.data[["Query_Date"]], "%Y/%m/%d"),
      Abstract     = (function(x, n = 200L) { x <- base::as.character(x); i <- base::nchar(x) > n; x[i] <- base::paste0(base::substr(x[i], 1L, n), "…"); x })(.data[["abstract"]])
    ) |>
    dplyr::rename(
      Guideline       = .data[["Guideline.number"]],
      `Trial ID`      = .data[["ID"]],
      `Publication DOI` = .data[["doi"]],
      Title           = .data[["title"]],
      Journal         = .data[["jabbrv"]],
      Condition       = .data[["Short..working.title."]]
    )

  sel_front(out, c(
    "Program","Guideline","Query Date","Trial ID","pmid","Publication DOI","Title","Abstract","Journal","Condition"
  )) |> dplyr::distinct()
}

# Cache the data frames not renderers
pubmed_nct_df <- shiny::reactive({
  render_pubmed_table(raw_tables()[["NCT_PM"]])
}) |> shiny::bindCache(mtime_reader())

pubmed_isr_df <- shiny::reactive({
  render_pubmed_table(raw_tables()[["ISRCTN_PM"]])
}) |> shiny::bindCache(mtime_reader())

pubmed_nihr_df <- shiny::reactive({
  render_pubmed_table(raw_tables()[["NIHR_PM"]])
}) |> shiny::bindCache(mtime_reader())

pubmed_eu_df <- shiny::reactive({
  render_pubmed_table(raw_tables()[["EU_PM"]])
}) |> shiny::bindCache(mtime_reader())

output$pubmed_nct    <- DT::renderDT(pubmed_nct_df(),  options = dt_opts_client, server = FALSE, filter = "top")
output$pubmed_isrctn <- DT::renderDT(pubmed_isr_df(),  options = dt_opts_client, server = FALSE, filter = "top")
output$pubmed_nihr   <- DT::renderDT(pubmed_nihr_df(), options = dt_opts_client, server = FALSE, filter = "top")
output$pubmed_eu     <- DT::renderDT(pubmed_eu_df(),   options = dt_opts_client, server = FALSE, filter = "top")

```

```{r ServerUserInteractions, context = "server", echo = FALSE}

#### Functionality to add / remove / archive /comment

### ADD SINGLE TRIAL
  
# SQL template for adding single trial
sql_add <-
  "INSERT INTO Trial_Ids ([Program], [Guideline.number], [URL], [?registry]) VALUES (?program_value, ?Guideline_Reference, ?URL, ?ID)"

# Reactive to create SQL statement to add single trial
exp_add <- shiny::reactive({
  DBI::sqlInterpolate(
    pool_con,
    sql_add,
    registry = DBI::SQL(input$registry_add),
    program_value = input$guideline_program_add,
    Guideline_Reference = input$guideline_reference_add,
    URL = stringr::str_trim(input$URL_add),
    ID = stringr::str_trim(input$ID_add)
  )
})

# Single trial add logic
shiny::observeEvent(input$button_add, {
  valid_id_check <-
    stringr::str_detect(
      stringr::str_trim(input$ID_add),
      stringr::str_c(NCT_pattern, EU_pattern, ISRCTN_pattern, NIHR_pattern, sep = "|")
    )

  if (valid_id_check) {
    shinybusy::show_modal_spinner(spin = "semipolar", color = "#344feb", text = "Adding Trial - please wait while the dashboard refreshes in background....")

    DBI::dbExecute(pool_con, exp_add())

    refresh_all_data()

    shinybusy::remove_modal_spinner()

    output$single_result <- shiny::renderUI({
      shiny::HTML(as.character(div(
        style = "color: green;",
        "Trial Added!"
      )))
    })
  } else if (!valid_id_check) {
    output$single_result <- shiny::renderUI({
      shiny::HTML(as.character(div(
        style = "color: red;",
        "Error - Invalid trial ID reference number, please check ID against the above approved formats"
      )))
    })
  }
})

## ADD MULTIPLE TRIALS

# Function to allow downloading of template
output$downloadtemplate <- shiny::downloadHandler(
  filename = function() {
    "trialuploadtemplate.csv"
  },
  content = function(file) {
    readr::write_csv(
      readr::read_csv("trialuploadtemplate.csv",
        col_types = readr::cols(.default = readr::col_character())
      ),
      file,
      na = ""
    )
  }
)

# Reactive for multiple uploads
to_add <- shiny::reactive({
  req(input$uploadtemplate)
  readr::read_csv(input$uploadtemplate$datapath,
                  col_types = readr::cols(.default = readr::col_character()))
})

# Multiple upload logic
shiny::observeEvent(input$uploadtemplate, {
  df <- to_add()
  NCT_check    <- stringr::str_detect(tidyr::replace_na(df$NCT_Ids, ""), NCT_pattern)
  EU_check     <- stringr::str_detect(tidyr::replace_na(df$EU_Ids, ""), EU_pattern)
  ISRCTN_check <- stringr::str_detect(tidyr::replace_na(df$ISRCTN_Ids, ""), ISRCTN_pattern)
  NIHR_check   <- stringr::str_detect(tidyr::replace_na(df$NIHR_Ids, ""), NIHR_pattern)
  Valid_ID     <- NCT_check | EU_check | ISRCTN_check | NIHR_check

  errors <- which(!Valid_ID)

  ## Commented out as only used for debugging
  # output$errors <- shiny::renderText({
  #   paste0("errors = ", as.character(errors))
  # })
  # output$errors_length <- shiny::renderText({
  #   paste0("errors_length = ", as.character(length(errors)))
  # })

  if (length(errors) > 0L) {
    output$multi_result <- shiny::renderText({
      shiny::HTML(as.character(div(
        style = "color: red;",
        paste(
          "ERROR - Missing or incorrect Trial ID on line(s)", as.character(errors),
          ", please correct these IDs and reupload the file"
        )
      )))
    })
  } else if (length(errors) == 0L) {
    output$multi_result <- shiny::renderText({
      shiny::HTML(as.character(div(
        style = "color: green;",
        "File has passed input checks and is ready for upload"
      )))
    })
  }
})
shiny::observeEvent(input$button_add_multi, {
  NCT_check <- stringr::str_detect(tidyr::replace_na(to_add()$NCT_Ids, ""), NCT_pattern)
  EU_check <- stringr::str_detect(tidyr::replace_na(to_add()$EU_Ids, ""), EU_pattern)
  ISRCTN_check <- stringr::str_detect(tidyr::replace_na(to_add()$ISRCTN_Ids, ""), ISRCTN_pattern)
  NIHR_check <- stringr::str_detect(tidyr::replace_na(to_add()$NIHR_Ids, ""), NIHR_pattern)
  Valid_ID <- {
    NCT_check | EU_check | ISRCTN_check | NIHR_check
  }
  multi_errors <- which(!Valid_ID)

  ## Commented out as only used for debugging
  # output$multi_errors <- shiny::renderText({
  #   paste0("multi_errors = ", as.character(multi_errors))
  # })
  # output$multi_errors_length <- shiny::renderText({
  #   paste0("multi_errors_length = ", as.character(length(multi_errors)))
  # })

  if (length(multi_errors) == 0L) {
    shinybusy::show_modal_spinner(spin = "semipolar", color = "#344feb", text = "Adding Trials - please wait while the dashboard refreshes in background....")

    DBI::dbAppendTable(pool_con, "Trial_Ids", to_add())

    refresh_all_data()

    shinybusy::remove_modal_spinner()

    output$multi_result <- shiny::renderText({
      shiny::HTML(as.character(div(
        style = "color: green;",
        "Multiple Trials Added! - Trials should appear on Live Trial Info tab in 10 seconds. If not, please refresh browser"
      )))
    })
  } else if (length(multi_errors) > 0L) {
    output$multi_result <- shiny::renderText({
      shiny::HTML(as.character(div(
        style = "color: red;",
        "Error - Please correct errors in trial ID numbers on upload sheet before resubmitting"
      )))
    })
  }
})

#### REMOVE OR ARCHIVE TRIALS

# SQL template for deleting trial id from Trial_Ids
sql_delete <- "DELETE FROM Trial_Ids WHERE ?ColID = ?ID_Selected"

# Reactive to pull id to insert into SQL delete request
exp_delete <- shiny::reactive({
  DBI::sqlInterpolate(
    pool_con,
    sql_delete,
    ColID = DBI::SQL(dplyr::case_when(
      input$registry_remove == "NIHR_Ids" ~ "REPLACE(REPLACE(NIHR_Ids, '-', ''),'/','')",
      TRUE ~ input$registry_remove
    )),
    ID_Selected = if (input$registry_remove == "NIHR_Ids") {
      stringr::str_replace_all(input$ID_remove, "(/)|(-)", "")
    } else {
      input$ID_remove
    }
  )
})

# Render output [used in debugging when enabled in UI]
output$exp_delete <- shiny::renderText(exp_delete())

#Delete logic
shiny::observeEvent(input$button_delete, {
  shinybusy::show_modal_spinner(spin = "semipolar", color = "#344feb", text = "Deleting Trial - please wait while the dashboard refreshes in background....")

  DBI::dbExecute(pool_con, exp_delete())

  refresh_all_data()

  shinybusy::remove_modal_spinner()

  output$success_delete <- shiny::renderText("Trial Deleted! Refresh browser for this to update on the live trial lists")
})

#Update remove list
shiny::observeEvent(input$registry_remove, {
  choices_list <- DBI::dbReadTable(pool_con, "Trial_Ids") |>
    dplyr::select(ids = input$registry_remove) |>
    tidyr::drop_na() |>
    dplyr::arrange(stringr::str_remove_all(ids, "[A-Z]|-")) |> 
    dplyr::pull(ids)
  
  shiny::updateSelectInput(session, "ID_remove", choices = choices_list)
  
  #Commented out (for debugging)
  #output$choices_list <- shiny::renderText(choices_list)
  
})

# SQL template for SQL archive select statement
sql_archive <- "SELECT * FROM ?Orig_Table WHERE ?ColID = ?ID_Selected"

# Reactive for pulling id to insert into SQL archiving request
exp_archive_pull <- shiny::reactive({
  DBI::sqlInterpolate(
    pool_con,
    sql_archive,
    Orig_Table = DBI::SQL(stringr::str_sub(input$registry_remove, end = -5L)),
    ColID = DBI::SQL(dplyr::case_when(
      input$registry_remove == "NCT_Ids" ~ "NCTId",
      input$registry_remove == "NIHR_Ids" ~ "REPLACE(REPLACE(project_id,'-',''),'/','')",
      input$registry_remove == "ISRCTN_Ids" ~ "ISRCTN_No",
      input$registry_remove == "EU_Ids" ~ "EU_Ids"
    )),
    ID_Selected = if (input$registry_remove == "NIHR_Ids") {
      stringr::str_replace_all(input$ID_remove, "(/)|(-)", "")
    } else {
      input$ID_remove
    }
  )
})

# Render output [used in debugging when enabled in UI]
output$exp_archive <- shiny::renderText(exp_archive_pull())

#Archive logic
shiny::observeEvent(input$button_archive, {
  shinybusy::show_modal_spinner(spin = "semipolar", color = "#344feb", text = "Archiving Trial - please wait while the dashboard refreshes in background....")

  pulled_trial_data <- DBI::dbGetQuery(pool_con, exp_archive_pull()) |>
    dplyr::slice_max(Query_Date) |>
    dplyr::mutate("Archiving_Comments" = stringr::str_remove(paste(Comments, as.character(input$comments_archive), collapse = " "), "NA"))

  # write to db (append)
  DBI::dbWriteTable(pool_con, paste0(stringr::str_sub(input$registry_remove, end = -5L), "_rxv"), pulled_trial_data, append = TRUE)

  DBI::dbExecute(pool_con, exp_delete())

  refresh_all_data()

  shinybusy::remove_modal_spinner()

  # return some success message
  output$success_archive <- shiny::renderText("Trial Successfully Archived. It should disappear from live lists but if not please try refreshing browser")
})

# Server code for 'download SQLite databases' button
  
# Function to allow downloading of files
output$button_download_dbs <- shiny::downloadHandler(
  
filename = function() paste0("databases-", Sys.Date(), ".zip"),
  content  = function(file) {
    zip::zipr(
      zipfile = file,
      files   = c("TrialTracker-db.sqlite", "EU_temp_db.sqlite"),
      root    = file.path("inst", "extdata", "RSQLite_data"),
      recurse = FALSE,
      include_directories = FALSE
    )
  }
)
```
