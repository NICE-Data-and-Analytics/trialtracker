---
title: "Trialtracker Dashboard"
output:
  flexdashboard::flex_dashboard:
    orientation: rows
    theme:
      version: 5
      bootswatch: flatly
      "enable-dark-mode": false
runtime: shiny
---

```{r global_setup, echo = FALSE, include = FALSE}

knitr::opts_chunk$set(cache = FALSE)

#Configure logging function
log_msg <- trialtracker:::configure_dashboard_logging()

# DB initialisation
db_path_abs <- trialtracker:::resolve_db_path_in_app()
pool_con <- trialtracker:::init_pool_with_pragmas(db_path_abs, log_fun = log_msg)


# DT options (server for big tables; client for smaller PubMed tables)
dt_opts_server <- list(pageLength = 50L, lengthMenu = c(25L, 50L, 100L), deferRender = TRUE, processing = TRUE, searchDelay = 400, dom = "tip")
dt_opts_client <- list(pageLength = 25L, dom = "tip")

```

```{r setup, context="server", echo=FALSE, include=FALSE}

# Logging
options(shiny.sanitize.errors = FALSE)
options(shiny.fullstacktrace = TRUE)
options(shiny.error = function() {
  # geterrmessage() is a character string; safe to log
  msg <- tryCatch(geterrmessage(), error = function(e) "<could not read geterrmessage()>")
  log_msg("SHINY ERROR:", msg)

  # capture something useful, but never risk crashing the handler itself
  try(utils::capture.output(sys.calls(), file = getOption("trialtracker.log_file"), append = TRUE), silent = TRUE)
  try(utils::capture.output(traceback(50), file = getOption("trialtracker.log_file"), append = TRUE), silent = TRUE)

  invisible(NULL)
})

# Close pool on session end (safe even if pool_con is NULL)
shiny::onStop(function() {
  try({
    if (!is.null(pool_con)) pool::poolClose(pool_con)
  }, silent = TRUE)
})

# Update reactive - this changes when the database file changes which is the trigger to update various tables
db_mtime <- shiny::reactivePoll(
  intervalMillis = 2000,
  session = session,
  checkFunc = function() {
    as.numeric(file.info(db_path_abs)$mtime)
  },
  valueFunc = function() {
    file.info(db_path_abs)$mtime
  }
)
```

```{css, echo=FALSE}
#button_download_dbs.btn,
#downloadtemplate.btn {
  width: auto !important;
  min-width: 0;
}
```

Live Trial Info
======================================================

**`r shiny::textOutput("last_refreshed_txt_live", inline = TRUE)`**

Row {.tabset .tabset-fade}
--------------------------------------------------------

### ClinicalTrials.gov

```{r CTGlive}
DT::DTOutput("live_trial_table_nct")
```

### ISRCTN

```{r ISCTNlive}
DT::DTOutput("live_trial_table_isrctn")
```

### NIHR

```{r NIHRlive}
DT::DTOutput("live_trial_table_nihr")
```

### Clinicaltrials.eu

```{r EUlive}
DT::DTOutput("live_trial_table_eu")
```

Recent Status Changes
======================================================

**`r shiny::textOutput("last_refreshed_txt_recent", inline = TRUE)`**

**Changes are from 31 days ago**

Row {.tabset .tabset-fade}
--------------------------------------------------------

### ClinicalTrials.gov

```{r NCTmonthlychange}
DT::DTOutput("nct_monthly_change")
```

### ISRCTN

```{r ISRCTNmonthlychange}
DT::DTOutput("isrctn_monthly_change")
```

### NIHR

```{r NIHRmonthlychange}
DT::DTOutput("nihr_monthly_change")
```

### Clinicaltrials.eu

```{r Clinicaltrialseumonthlychange}
DT::DTOutput("clinicaltrialseu_monthly_change")
```

No Changes in Last 6m
======================================================

**`r shiny::textOutput("last_refreshed_txt_nochg", inline = TRUE)`**

Row {.tabset .tabset-fade}
--------------------------------------------------------

### ClinicalTrials.gov

```{r nochangeCTG}
DT::DTOutput("no_change_nct_sql")
```

### ISRCTN

```{r nochangeISRCTN}
DT::DTOutput("no_change_isrctn_sql")
```

### NIHR

```{r nochangeNIHR}
DT::DTOutput("no_change_nihr_sql")
```

### Clinicaltrials.eu

```{r nochangeEU}
DT::DTOutput("no_change_cteu_sql")
```

Pubmed Publications
======================================================

**`r shiny::textOutput("last_refreshed_txt_pub", inline = TRUE)`**

Row {.tabset .tabset-fade}
--------------------------------------------------------

### ClinicalTrials.gov

```{r CTGpubstable}
DT::DTOutput("pubmed_nct")
```

### ISRCTN

```{r ISRCTNpubstable}
DT::DTOutput("pubmed_isrctn")
```

### NIHR

```{r NIHRpubstable}
DT::DTOutput("pubmed_nihr")
```

### Clinicaltrials.eu

```{r EUpubstable}
DT::DTOutput("pubmed_eu")
```

Add/Remove Trials
======================================================

Row {.tabset .tabset-fade}
--------------------------------------------------------

### Add Trial

There are two ways to add trials:

1.  Add one at a time, choosing the relevant registry button, completing the guideline number, trial ID, and URL boxes, then pressing 'add trial'.
2.  Add more than one trial at once by uploading a spreadsheet containing relevant details using the 'choose file' box on the next tab.

**Note that Trial ID reference number must be in the correct format. Eg:**

-   Clinicaltrials.gov - "NCT03883230"
-   ISRCTN - "ISRCTN11735271"
-   NIHR - "14-158-02" or "14/158/02" or "RP-PG-0109-10056"
-   Clinicaltrials.eu - "2007-003673-21" (omit the last two letters designating country)

```{r AddTrialsSideBySide}

# One row with two columns. Uses Bootstrap 5 utilities (works with your theme).
shiny::fluidRow(
  class = "g-3",  # nice gutter spacing

  # =========================
  # LEFT: Add Single Trial
  # =========================
  shiny::column(
    width = 6,
    shiny::div(
      class = "d-flex",
      shiny::div(
        class = "card flex-fill mb-0",
        shiny::div(class = "card-header h5 mb-0", "Add Single Trial"),
        shiny::div(
          class = "card-body",
          shiny::radioButtons(
            "registry_add",
            label = "Select Registry",
            choices = c(
              "Clinicaltrials.gov" = "NCT_Ids",
              "ISRCTN"             = "ISRCTN_Ids",
              "NIHR"               = "NIHR_Ids",
              "Clinicaltrials.eu"  = "EU_Ids"
            )
          ),
          shiny::selectInput(
            "guideline_program_add",
            label   = "Enter program description",
            choices = c("COVID", "IP", "Other"),
            selected = "COVID"
          ),
          shiny::textInput(
            "guideline_reference_add",
            label = "Enter guideline number(s)",
            placeholder = "e.g. CG179"
          ),
          shiny::textInput(
            "ID_add",
            label = "Enter Trial ID reference number",
            placeholder = "e.g. NCT03597750"
          ),
          shiny::textInput(
            "URL_add",
            label = "Paste URL to trial page in registry",
            placeholder = "e.g. https://clinicaltrials.gov/ct2/show/NCT03597750"
          ),
          shiny::actionButton("button_add",
                              label = "Add single trial",
                              icon  = shiny::icon("plus-circle"),
                              class = "btn btn-primary"),
          shiny::div(class = "mt-2", shiny::uiOutput("single_result"))
        )
      )
    )
  ),

  # =========================
  # RIGHT: Add Multiple Trials
  # =========================
  shiny::column(
    width = 6,
    shiny::div(
      class = "d-flex",
      shiny::div(
        class = "card flex-fill mb-0",
        shiny::div(class = "card-header h5 mb-0", "Add Multiple Trials via CSV File"),
        shiny::div(
          class = "card-body",
          # compact, non-stretching download button
          shiny::tags$div(
            class = "d-inline-block mb-2",
            shiny::downloadButton(
              "downloadtemplate",
              label = "Download template",
              class = "btn btn-secondary btn-sm"
            )
          ),
          shiny::fileInput(
            "uploadtemplate",
            label = "Upload completed template",
            multiple = FALSE,
            accept = ".csv"
          ),
          shiny::actionButton("button_add_multi",
                              label = "Add trial spreadsheet",
                              icon  = shiny::icon("file-upload"),
                              class = "btn btn-primary"),
          shiny::div(
            class = "mt-3",
            shiny::uiOutput("multi_result"),
            shiny::textOutput("multi_error"),
            shiny::textOutput("multi_fail"),
            shiny::textOutput("multi_success")
          )
        )
      )
    )
  )
)
```

### Remove or Archive Trial

Select relevant registry and trial ID reference number below, along with any archiving comments.

'Archiving' moves the trial information from the live lists to the relevant archived trials list, where it will no longer be updated. 'Deleting' will remove the trial from the live lists and information will not be stored

```{r Removetab}

shiny::fluidRow(class = "g-3", shiny::column(width = 12, shiny::div(
  class = "card",
  shiny::div(class = "card-header h5 mb-0", "Remove or Archive Trial"),
  shiny::div(
    class = "card-body",
    
    # Inputs
    shiny::fluidRow(
      shiny::column(
        width = 4,
        shiny::radioButtons(
          "registry_remove",
          label = "Registry",
          choices = c(
            "Clinicaltrials.gov" = "NCT_Ids",
            "ISRCTN"             = "ISRCTN_Ids",
            "NIHR"               = "NIHR_Ids",
            "Clinicaltrials.eu"  = "EU_Ids"
          )
        )
      ),
      shiny::column(
        width = 8,
        shiny::selectInput("ID_remove", label = "Select Trial ID reference number", choices = ""),
        shiny::textAreaInput(
          "comments_archive",
          label = "Archive Comments",
          placeholder = "Optional notes for the archive recordâ€¦",
          rows = 2,
          resize = "vertical"
        )
      )
    ),
    
    # Actions (compact, consistent sizing)
    shiny::div(
      class = "d-flex gap-2 mt-2 flex-wrap",
      shiny::actionButton(
        "button_delete",
        "Delete trial",
        icon  = shiny::icon("trash"),
        class = "btn btn-danger btn-sm"
      ),
      shiny::actionButton(
        "button_archive",
        "Archive trial",
        icon  = shiny::icon("archive"),
        class = "btn btn-warning btn-sm"
      ),
      shiny::downloadButton(
        "button_download_dbs",
        label = "Download SQLite data",
        class = "btn btn-secondary btn-sm"
      )
    )
    ,
    
    # Messages
    shiny::div(
      class = "mt-2",
      shiny::textOutput("success_delete"),
      shiny::textOutput("success_archive")
    )
  )
)))

```

Archived Trials
======================================================

Row {.tabset .tabset-fade}
--------------------------------------------------------

### ClinicalTrials.gov Archive

```{r CG.govarchive, echo=FALSE}
DT::DTOutput("archive_nct")
```

### ISRCTN Archive

```{r ISRCTNarchivetable, echo=FALSE}
DT::DTOutput("archive_isrctn")
```

### NIHR Archive

```{r NIHRarchivetable, echo=FALSE}
DT::DTOutput("archive_nihr")
```

### EU Archive
```{r EUarchivetable, echo=FALSE}
DT::DTOutput("archive_eu")
```

```{r ServerCodeUpdates, context = "server", echo = FALSE}

# Helper to render a "last refreshed" string into a given output ID
render_last_refreshed <- function(id) {
  output[[id]] <- shiny::renderText({
    ts <- db_mtime()
    if (is.na(ts)) return("ðŸ”„ Unknown")
    utc <- format(ts, "%Y-%m-%d %H:%M", tz = "UTC")
    paste0("ðŸ”„ Last refreshed at: ", utc, " UTC")
  })
}

# Create multiple refresh outputs for each page
render_last_refreshed("last_refreshed_txt_live")
render_last_refreshed("last_refreshed_txt_recent")
render_last_refreshed("last_refreshed_txt_nochg")

```

```{r ServerLiveTrialInfo, context = "server", echo = FALSE}

# --- Execute inside renderDT (reactivity stays here) ---
output$live_trial_table_nct <- DT::renderDT({
  db_mtime()   # dependency only: forces re-run whenever sqlite file changes
  sql <- trialtracker:::nct_latest_sql_from_trial_ids(pool_con)
  df  <- trialtracker:::safe_db_getquery(pool_con, sql, "live_trial_table_nct")
  if ("Error" %in% names(df)) return(df)
  if (!nrow(df)) return(df)
  df
}, options = dt_opts_server, server = TRUE, filter = "top")

# --- Execute inside renderDT (reactivity happens here) ---
output$live_trial_table_isrctn <- DT::renderDT({
  db_mtime()   # dependency only: forces re-run whenever sqlite file changes
  sql <- trialtracker:::isr_latest_sql_from_trial_ids(pool_con)
  df  <- trialtracker:::safe_db_getquery(pool_con, sql, label = "live_trial_table_isrctn")
  if ("Error" %in% names(df)) return(df)
  if (!nrow(df)) return(df)
  df
}, options = dt_opts_server, server = TRUE, filter = "top")

# --- Execute inside renderDT (reactivity here) ---
output$live_trial_table_nihr <- DT::renderDT({
  db_mtime()   # dependency only: forces re-run whenever sqlite file changes
  sql <- trialtracker:::nihr_latest_sql_from_trial_ids(pool_con)
  df  <- trialtracker:::safe_db_getquery(pool_con, sql, label = "live_trial_table_nihr")
  if ("Error" %in% names(df)) return(df)
  if (!nrow(df)) return(df)
  df
}, options = dt_opts_server, server = TRUE, filter = "top")

# --- Execute inside renderDT (reactivity here; no sel_front needed) ---
output$live_trial_table_eu <- DT::renderDT({
  db_mtime()   # dependency only: forces re-run whenever sqlite file changes
  sql <- trialtracker:::eu_latest_sql_from_trial_ids(pool_con)
  df  <- trialtracker:::safe_db_getquery(pool_con, sql, label = "live_trial_table_eu")
  if ("Error" %in% names(df)) return(df)
  if (!nrow(df)) return(df)
  df
}, options = dt_opts_server, server = TRUE, filter = "top")


```

```{r ServerRecentStatusChanges, context="server", echo=FALSE}

nct_sql    <- trialtracker:::nct_recent_changes_sql(pool_con, lookback_days = 31L)
isrctn_sql <- trialtracker:::isrctn_recent_changes_sql(pool_con, lookback_days = 31L)
nihr_sql   <- trialtracker:::nihr_recent_changes_sql(pool_con, lookback_days = 31L)
eu_sql     <- trialtracker:::eu_recent_changes_sql(pool_con, lookback_days = 31L)

# ---- Generic renderer for â€œRecent Status Changesâ€ tables ----
# Keeps index.Rmd DRY: run query safely, bail out on Error/empty, then format.
render_recent_changes <- function(sql_text, label, formatter) {
  DT::renderDT({
    db_mtime()

    df <- trialtracker:::safe_db_getquery(pool_con, sql_text, label = label)
    if ("Error" %in% names(df)) return(df)
    if (!nrow(df)) return(df)

    formatter(df)
  }, options = dt_opts_server, server = TRUE, filter = "top")
}

# --- wire outputs ---
output$nct_monthly_change              <- render_recent_changes(nct_sql, "render_nct", trialtracker:::format_recent_changes_nct)
output$isrctn_monthly_change           <- render_recent_changes(isrctn_sql, "render_isrctn", trialtracker:::format_recent_changes_isrctn)
output$nihr_monthly_change             <- render_recent_changes(nihr_sql, "render_nihr", trialtracker:::format_recent_changes_nihr)
output$clinicaltrialseu_monthly_change <- render_recent_changes(eu_sql, "render_eu", trialtracker:::format_recent_changes_eu)
```

```{r ServerNoChangesInLast6M, context = "server", echo = FALSE}

# Define DT options for wide, non-paginated tables
nochange_dt_opts <- list(bPaginate = FALSE, scrollY = "500px")

# ---- specs (one per output) ----
nochange_specs <- list(

  no_change_nct_sql = list(
    table_name = "NCT",
    id_col = "NCTId",
    rename_list = c(
      "Guideline" = "Guideline.number",
      `NCT ID` = "NCTId",
      `Org Study ID` = "OrgStudyId",
      Title = "BriefTitle",
      Status = "OverallStatus",
      `Primary Completion Date` = "PrimaryCompletionDate",
      `Completion Date` = "CompletionDate",
      `Results Submit Date` = "ResultsFirstSubmitDate",
      `Results Post Date` = "ResultsFirstPostDate",
      `Last Update` = "LastUpdatePostDate"
    ),
    drop_cols = "SeeAlsoLinkURL",
    reorder_cols = c(
      "Program", "Guideline", "Date Added", "NCT ID", "Org Study ID", "Title", "Status",
      "Primary Completion Date", "Completion Date", "Results Submit Date", "Results Post Date", "Last Update"
    ),
    date_cols = c(
      "PrimaryCompletionDate", "CompletionDate",
      "ResultsFirstSubmitDate", "ResultsFirstPostDate", "LastUpdatePostDate"
    )
  ),

  no_change_isrctn_sql = list(
    table_name = "ISRCTN",
    id_col = "ISRCTN_No",
    rename_list = c(
      "Guideline" = "Guideline.number",
      `ISRCTN ID` = "ISRCTN_No",
      Title = "Public_Title",
      `Scientific Title` = "Scientific_Title",
      `Recruitment Status` = "Recruitment_Status",
      `Results completed date` = "Results_date_completed",
      `Results URL` = "Results_url_link",
      `Results summary` = "Results_summary",
      `Results posted date` = "Results_date_posted",
      `Results published date` = "Results_date_first_publication"
    ),
    reorder_cols = c(
      "Program", "Guideline", "Date Added", "ISRCTN ID", "Title", "Scientific Title",
      "Recruitment Status", "Results URL", "Results summary",
      "Results completed date", "Results posted date", "Results published date"
    ),
    extra_mutate = ~ dplyr::mutate(.,
      Results_date_completed = lubridate::dmy(Results_date_completed),
      Results_date_posted = lubridate::dmy(Results_date_posted),
      Results_date_first_publication = lubridate::dmy(Results_date_first_publication)
    )
  ),

  no_change_nihr_sql = list(
    table_name = "NIHR",
    id_col = "project_id",
    rename_list = c(
      "Guideline" = "Guideline.number",
      `NIHR ID` = "project_id",
      `Project Title` = "project_title",
      Status = "project_status",
      `End Date` = "end_date"
    ),
    reorder_cols = c("Program", "Guideline", "Date Added", "NIHR ID", "Project Title", "Status", "End Date")
  ),

  no_change_cteu_sql = list(
    table_name = "EU",
    id_col = "X_id",
    rename_list = c(
      "Guideline" = "Guideline.number",
      `Clinicaltrials.eu ID` = "X_id",
      `End of Trial Status` = "p_end_of_trial_status",
      Title = "a3_full_title_of_the_trial",
      `Abbreviated Title` = "a32_name_or_abbreviated_title_of_the_trial_where_available",
      `Sponsor ID` = "a41_sponsors_protocol_code_number"
    ),
    reorder_cols = c(
      "Program", "Guideline", "Date Added", "Clinicaltrials.eu ID", "Title",
      "Abbreviated Title", "End of Trial Status", "Sponsor ID"
    )
  )
)

# ---- wire outputs (loop) ----
for (out_id in names(nochange_specs)) {
  spec <- nochange_specs[[out_id]]

  output[[out_id]] <- DT::renderDT({
    db_mtime()  # dependency only: rerun whenever sqlite file mtime changes

    # Call with only the args present in the spec (keeps defaults intact)
    args <- c(list(conn = pool_con), spec)

    do.call(trialtracker:::generate_nochange_table_sql, args)
  }, options = nochange_dt_opts, filter = "top")
}

```


```{r ServerPubMed, context = "server", echo = FALSE}

# --- Execute + tidy for a given registry ---
run_pubmed <- function(reg) {
  sql <- trialtracker:::pubmed_sql(pool_con, reg)
  df  <- trialtracker:::safe_db_getquery(pool_con, sql, label = "run_pubmed")
  if ("Error" %in% names(df)) return(df)
  if (!nrow(df)) return(df)

  df |>
    dplyr::mutate(
      dplyr::across(where(is.character), ~ trialtracker:::clean_text_pubmed((.x))),
      `Query Date` = format(trialtracker:::coerce_pm_date(.data[["Query_Date"]]), "%Y/%m/%d"),
      Abstract     = trialtracker:::truncate_str(.data[["Abstract"]], 200L)
    ) |>
    dplyr::select(
      "Program","Guideline","Query Date","Trial ID","pmid",
      "Publication DOI","Title","Abstract","Journal","Working Title"
    ) #|>
    #dplyr::distinct()
}

# --- Outputs (client-side DT) ---
output$pubmed_nct <- DT::renderDT({
  db_mtime()               # dependency only: rerun on DB change
  run_pubmed("NCT")
}, options = dt_opts_client, server = TRUE, filter = "top")

output$pubmed_isrctn <- DT::renderDT({
  db_mtime()
  run_pubmed("ISRCTN")
}, options = dt_opts_client, server = TRUE, filter = "top")

output$pubmed_nihr <- DT::renderDT({
  db_mtime()
  run_pubmed("NIHR")
}, options = dt_opts_client, server = TRUE, filter = "top")

output$pubmed_eu <- DT::renderDT({
  db_mtime()
  run_pubmed("EU")
}, options = dt_opts_client, server = TRUE, filter = "top")
```

```{r ServerArchive, context = "server", echo = FALSE}

# renderer for archive tables (DT-only wrapper)
archive_dt <- function(pool, table, rename_map, drop_cols = character()) {
  df <- trialtracker:::archive_table_df(
    con = pool,
    table = table,
    rename_map = rename_map,
    drop_cols = drop_cols,
    log_fun = log_msg
  )

  DT::datatable(
    df,
    options = list(pageLength = 25, scrollY = "500px"),
    filter = "top"
  )
}

# ---- archive table specs ----
archive_specs <- list(
  archive_nct = list(
    table = "NCT_rxv",
    drop_cols = c("SeeAlsoLinkURL"),
    rename_map = c(
      "Guideline"               = "Guideline.number",
      "NCT ID"                  = "NCTId",
      "Org Study ID"            = "OrgStudyId",
      "Title"                   = "BriefTitle",
      "Status"                  = "OverallStatus",
      "Primary Completion Date" = "PrimaryCompletionDate",
      "Completion Date"         = "CompletionDate",
      "Results Submit Date"     = "ResultsFirstSubmitDate",
      "Results Post Date"       = "ResultsFirstPostDate",
      "Last Update"             = "LastUpdatePostDate",
      "Archiving Comments"      = "Archiving_Comments"
    )
  ),
  archive_isrctn = list(
    table = "ISRCTN_rxv",
    drop_cols = character(),
    rename_map = c(
      "Program or Guideline"    = "Guideline.number",
      "ISRCTN ID"               = "ISRCTN_No",
      "Title"                   = "Public_Title",
      "Scientific Title"        = "Scientific_Title",
      "Recruitment Status"      = "Recruitment_Status",
      "Results completed date"  = "Results_date_completed",
      "Results URL"             = "Results_url_link",
      "Results summary"         = "Results_summary",
      "Results posted date"     = "Results_date_posted",
      "Results published date"  = "Results_date_first_publication",
      "Archiving Comments"      = "Archiving_Comments"
    )
  ),
  archive_nihr = list(
    table = "NIHR_rxv",
    drop_cols = character(),
    rename_map = c(
      "Program or Guideline"    = "Guideline.number",
      "NIHR ID"                 = "project_id",
      "Project Title"           = "project_title",
      "Status"                  = "project_status",
      "End Date"                = "end_date",
      "Archiving Comments"      = "Archiving_Comments"
    )
  ),
  archive_eu = list(
    table = "EU_rxv",
    drop_cols = c(
      "a31_title_of_the_trial_for_lay_people_in_easily_understood_ie_nontechnical_language",
      "EU_Ids"
    ),
    rename_map = c(
      "Program or Guideline"    = "Guideline.number",
      "Clinicaltrials.eu ID"    = "X_id",
      "End of Trial Status"     = "p_end_of_trial_status",
      "Title"                   = "a3_full_title_of_the_trial",
      "Abbreviated Title"       = "a32_name_or_abbreviated_title_of_the_trial_where_available",
      "Sponsor ID"              = "a41_sponsors_protocol_code_number",
      "Archiving Comments"      = "Archiving_Comments"
    )
  )
)

# ---- wire outputs ----
for (out_id in names(archive_specs)) {
  spec <- archive_specs[[out_id]]

  output[[out_id]] <- DT::renderDT({
    db_mtime()  # rerun whenever sqlite file mtime changes (CRON, add/delete/archive)

    archive_dt(
      pool       = pool_con,
      table      = spec$table,
      rename_map = spec$rename_map,
      drop_cols  = spec$drop_cols
    )
  }, server = FALSE)
}

```

```{r ServerUserInteractions, context = "server", echo = FALSE}

#### Functionality to add / remove / archive /comment

### ADD SINGLE TRIAL
  
# SQL template for adding single trial
sql_add <-
  "INSERT INTO Trial_Ids ([Program], [Guideline.number], [URL], [?registry]) VALUES (?program_value, ?Guideline_Reference, ?URL, ?ID)"

# Reactive to create SQL statement to add single trial
exp_add <- shiny::reactive({
  DBI::sqlInterpolate(
    pool_con,
    sql_add,
    registry = DBI::SQL(input$registry_add),
    program_value = input$guideline_program_add,
    Guideline_Reference = input$guideline_reference_add,
    URL = stringr::str_trim(input$URL_add),
    ID = stringr::str_trim(input$ID_add)
  )
})

# Single trial add logic
shiny::observeEvent(input$button_add, {

  # Validate ID against the selected registry (input$registry_add is e.g. "NCT_Ids")
  valid_id_check <- trialtracker:::is_valid_trial_id(input$ID_add, registry = input$registry_add)

  if (valid_id_check) {
    shinybusy::show_modal_spinner(
      spin  = "semipolar",
      color = "#344feb",
      text  = "Adding Trial - please wait while the dashboard refreshes in background...."
    )

    DBI::dbExecute(pool_con, exp_add())

    trialtracker::download_trial_info_wrapper_no_pm_or_email()

    shinybusy::remove_modal_spinner()

    output$single_result <- shiny::renderUI({
      shiny::HTML(as.character(div(
        style = "color: green;",
        "Trial Added!"
      )))
    })

  } else {
    output$single_result <- shiny::renderUI({
      shiny::HTML(as.character(div(
        style = "color: red;",
        "Error - Invalid trial ID reference number, please check ID against the above approved formats"
      )))
    })
  }
})

## ADD MULTIPLE TRIALS

# Function to allow downloading of template
output$downloadtemplate <- shiny::downloadHandler(
  filename = function() {
    "trialuploadtemplate.csv"
  },
  content = function(file) {
    readr::write_csv(
      readr::read_csv("trialuploadtemplate.csv",
        col_types = readr::cols(.default = readr::col_character())
      ),
      file,
      na = ""
    )
  }
)

# Reactive for multiple uploads
to_add <- shiny::reactive({
  req(input$uploadtemplate)
  readr::read_csv(input$uploadtemplate$datapath,
                  col_types = readr::cols(.default = readr::col_character()))
})

# Multiple upload logic
shiny::observeEvent(input$uploadtemplate, {
  df <- to_add()

  # Find rows with any invalid (non-empty) IDs across the known registry columns
  errors <- trialtracker:::invalid_upload_rows(df)

  ## Commented out as only used for debugging
  # output$errors <- shiny::renderText({
  #   paste0("errors = ", as.character(errors))
  # })
  # output$errors_length <- shiny::renderText({
  #   paste0("errors_length = ", as.character(length(errors)))
  # })

  if (length(errors) > 0L) {
    output$multi_result <- shiny::renderText({
      shiny::HTML(as.character(div(
        style = "color: red;",
        paste(
          "ERROR - Missing or incorrect Trial ID on line(s)", as.character(errors),
          ", please correct these IDs and reupload the file"
        )
      )))
    })
  } else {
    output$multi_result <- shiny::renderText({
      shiny::HTML(as.character(div(
        style = "color: green;",
        "File has passed input checks and is ready for upload"
      )))
    })
  }
})

shiny::observeEvent(input$button_add_multi, {

  # Re-check validity at the point of submission
  multi_errors <- trialtracker:::invalid_upload_rows(to_add())

  ## Commented out as only used for debugging
  # output$multi_errors <- shiny::renderText({
  #   paste0("multi_errors = ", as.character(multi_errors))
  # })
  # output$multi_errors_length <- shiny::renderText({
  #   paste0("multi_errors_length = ", as.character(length(multi_errors)))
  # })

  if (length(multi_errors) == 0L) {
    shinybusy::show_modal_spinner(
      spin  = "semipolar",
      color = "#344feb",
      text  = "Adding Trials - please wait while the dashboard refreshes in background...."
    )

    DBI::dbAppendTable(pool_con, "Trial_Ids", to_add())

    trialtracker::download_trial_info_wrapper_no_pm_or_email()

    shinybusy::remove_modal_spinner()

    output$multi_result <- shiny::renderText({
      shiny::HTML(as.character(div(
        style = "color: green;",
        "Multiple Trials Added! - Trials should appear on Live Trial Info tab in 10 seconds. If not, please refresh browser"
      )))
    })
  } else {
    output$multi_result <- shiny::renderText({
      shiny::HTML(as.character(div(
        style = "color: red;",
        "Error - Please correct errors in trial ID numbers on upload sheet before resubmitting"
      )))
    })
  }
})

#### REMOVE OR ARCHIVE TRIALS

# Helper function for refreshing the list of trials that can be removed or archived after a user deletes or archives a trial
refresh_remove_choices <- function() {
  choices_list <- DBI::dbReadTable(pool_con, "Trial_Ids") |>
    dplyr::select(ids = input$registry_remove) |>
    tidyr::drop_na() |>
    dplyr::arrange(stringr::str_remove_all(ids, "[A-Z]|-")) |>
    dplyr::pull(ids)

  shiny::updateSelectInput(session, "ID_remove", choices = choices_list)
}

# SQL template for deleting trial id from Trial_Ids
sql_delete <- "DELETE FROM Trial_Ids WHERE ?ColID = ?ID_Selected"

# Reactive to pull id to insert into SQL delete request
exp_delete <- shiny::reactive({
  DBI::sqlInterpolate(
    pool_con,
    sql_delete,
    ColID = DBI::SQL(dplyr::case_when(
      input$registry_remove == "NIHR_Ids" ~ "REPLACE(REPLACE(NIHR_Ids, '-', ''),'/','')",
      TRUE ~ input$registry_remove
    )),
    ID_Selected = trialtracker:::normalize_trial_id(input$ID_remove, input$registry_remove)
  )
})

# Render output [used in debugging when enabled in UI]
#output$exp_delete <- shiny::renderText(exp_delete())

#Delete logic
shiny::observeEvent(input$button_delete, {
  shinybusy::show_modal_spinner(spin = "semipolar", color = "#344feb", text = "Deleting Trial - please wait while the dashboard refreshes in background....")

  DBI::dbExecute(pool_con, exp_delete())
  refresh_remove_choices()

  shinybusy::remove_modal_spinner()

  output$success_delete <- shiny::renderText("Trial Deleted! Refresh browser for this to update on the live trial lists")
})

#Update remove list
shiny::observeEvent(input$registry_remove, refresh_remove_choices())
  
# SQL template for SQL archive select statement
sql_archive <- "SELECT * FROM ?Orig_Table WHERE ?ColID = ?ID_Selected"

# Reactive for pulling id to insert into SQL archiving request
exp_archive_pull <- shiny::reactive({
  DBI::sqlInterpolate(
    pool_con,
    sql_archive,
    Orig_Table = DBI::SQL(stringr::str_sub(input$registry_remove, end = -5L)),
    ColID = DBI::SQL(dplyr::case_when(
      input$registry_remove == "NCT_Ids" ~ "NCTId",
      input$registry_remove == "NIHR_Ids" ~ "REPLACE(REPLACE(project_id,'-',''),'/','')",
      input$registry_remove == "ISRCTN_Ids" ~ "ISRCTN_No",
      input$registry_remove == "EU_Ids" ~ "EU_Ids"
    )),
    ID_Selected = trialtracker:::normalize_trial_id(input$ID_remove, input$registry_remove)
  )
})

# Render output [used in debugging when enabled in UI]
#output$exp_archive <- shiny::renderText(exp_archive_pull())

#Archive logic
shiny::observeEvent(input$button_archive, {
  shinybusy::show_modal_spinner(spin = "semipolar", color = "#344feb", text = "Archiving Trial - please wait while the dashboard refreshes in background....")

  pulled_trial_data <- trialtracker:::safe_db_getquery(pool_con, exp_archive_pull(), label = "pulled_trial_data") |>
    dplyr::slice_max(Query_Date) |>
    dplyr::mutate("Archiving_Comments" = stringr::str_remove(paste(Comments, as.character(input$comments_archive), collapse = " "), "NA"))

  # write to db (append)
  DBI::dbWriteTable(pool_con, paste0(stringr::str_sub(input$registry_remove, end = -5L), "_rxv"), pulled_trial_data, append = TRUE)

  DBI::dbExecute(pool_con, exp_delete())
  refresh_remove_choices()

  shinybusy::remove_modal_spinner()

  # return some success message
  output$success_archive <- shiny::renderText("Trial Successfully Archived. It should disappear from live lists but if not please try refreshing browser")
})

# Server code for 'download SQLite databases' button
  
# Function to allow downloading of files
output$button_download_dbs <- shiny::downloadHandler(
  
filename = function() paste0("databases-", Sys.Date(), ".zip"),
  content  = function(file) {
    zip::zipr(
      zipfile = file,
      files   = c("TrialTracker-db.sqlite", "EU_temp_db.sqlite"),
      root    = file.path("inst", "extdata", "RSQLite_data"),
      recurse = FALSE,
      include_directories = FALSE
    )
  }
)
```
